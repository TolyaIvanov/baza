## Оглавление

1. [Functions](#Functions)
   * [lambda](#Как-лямбда-функции-работают-внутри)
   * [Overloading](#Перегрузка)
2. [Links and Pointers](#Links-and-Pointers)
3. 123
4. 3123
5. 123


# Functions

Лямбда-выражения в C++ — это краткая форма записи анонимных функторов

Другими словами, это просто синтаксический сахар. Синтаксис лямбда-функции определяется как:
```c++
[ capture clause ] (parameters) -> return-type  
{   
   definition of method   
} 
```
![lambda](https://senior.ua/storage/article/content/244f7fdd-8313-45a9-8cba-42ed385d309d.jpeg)

[:arrow_up:Оглавление](#Оглавление)

### Как лямбда функции работают внутри
***
```c++
[&i] ( ) { std::cout << i; }

// is equivalent to

struct anonymous
{
    int &m_i;
    anonymous(int &i) : m_i(i) {}
    inline auto operator()() const
    {
       std::cout << i;
    }
};
```
Компилятор генерирует уникальное замыкание, как указаны выше для каждой функции лямбды. Наконец секрет раскрыт.

Если вы захватите аргумент в качестве значения, то в замыкании будет создан член данных соответствующего типа.

Кроме того, вы можете объявить переменную / объект в аргументе лямбда-функции, который станет аргументом для вызова оператора, т.е. operator()

Преимущества использования лямбда-функции
 * Нулевая стоимость абстракции. Да! Вы правильно прочитали. Лямбда не влияет на производительность и так же быстра, как обычная функция.
 * Кроме того, код становится компактным, структурированным и выразительным.

[:arrow_up:Оглавление](#Оглавление)

### Перегрузка
***
Перегрузка ОПЕРАТОРА подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора. Функция оператора может быть определена как член класса, либо вне класса.

Перегрузить можно только те операторы, которые уже определены в C++. Создать новые операторы нельзя.

Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>). Рассмотрим простейший пример:
```c++
class Integer
{
private:
    int value;
public:
    Integer(int i): value(i) 
    {}
    const Integer operator+(const Integer& rv) const {
        return (value + rv.value);
    }
};
```
В данном случае, оператор оформлен как член класса, аргумент определяет значение, находящееся в правой части оператора. Вообще, существует два основных способа перегрузки операторов: глобальные функции, дружественные для класса, или подставляемые функции самого класса.

[:arrow_up:Оглавление](#Оглавление)

# Links and Pointers

1. 





