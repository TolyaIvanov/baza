## Оглавление

1. [Functions](#Functions)
   * [lambda](#Как-лямбда-функции-работают-внутри)
   * [Overloading](#Перегрузка)
2. [Links and Pointers](#Links-and-Pointers)
   * [Links](#links)
   * [Pointers](#pointers)
   * [RAII](#RAII)
3. 123
4. 3123
5. 123


# Functions

Лямбда-выражения в C++ — это краткая форма записи анонимных функторов

Другими словами, это просто синтаксический сахар. Синтаксис лямбда-функции определяется как:
```c++
[ capture clause ] (parameters) -> return-type  
{   
   definition of method   
} 
```
![lambda](https://senior.ua/storage/article/content/244f7fdd-8313-45a9-8cba-42ed385d309d.jpeg)

[:arrow_up:Оглавление](#Оглавление)

### Как лямбда функции работают внутри
***
```c++
[&i] ( ) { std::cout << i; }

// is equivalent to

struct anonymous
{
    int &m_i;
    anonymous(int &i) : m_i(i) {}
    inline auto operator()() const
    {
       std::cout << i;
    }
};
```
Компилятор генерирует уникальное замыкание, как указаны выше для каждой функции лямбды. Наконец секрет раскрыт.

Если вы захватите аргумент в качестве значения, то в замыкании будет создан член данных соответствующего типа.

Кроме того, вы можете объявить переменную / объект в аргументе лямбда-функции, который станет аргументом для вызова оператора, т.е. operator()

Преимущества использования лямбда-функции
 * Нулевая стоимость абстракции. Да! Вы правильно прочитали. Лямбда не влияет на производительность и так же быстра, как обычная функция.
 * Кроме того, код становится компактным, структурированным и выразительным.

[:arrow_up:Оглавление](#Оглавление)

### Перегрузка
***
Перегрузка ОПЕРАТОРА подразумевает создание функции, название которой содержит слово operator и символ перегружаемого оператора. Функция оператора может быть определена как член класса, либо вне класса.

Перегрузить можно только те операторы, которые уже определены в C++. Создать новые операторы нельзя.

Синтаксис перегрузки операторов очень похож на определение функции с именем operator@, где @ — это идентификатор оператора (например +, -, <<, >>). Рассмотрим простейший пример:
```c++
class Integer
{
private:
    int value;
public:
    Integer(int i): value(i) 
    {}
    const Integer operator+(const Integer& rv) const {
        return (value + rv.value);
    }
};
```
В данном случае, оператор оформлен как член класса, аргумент определяет значение, находящееся в правой части оператора. Вообще, существует два основных способа перегрузки операторов: глобальные функции, дружественные для класса, или подставляемые функции самого класса.

[:arrow_up:Оглавление](#Оглавление)

# Links and Pointers

### 1. links
```c++
    int x = 42;
    int& ref = x;  // ссылка на x
```
Здесь ref — псевдоним для x. 
Это не самостоятельная переменная, а просто ссылка на объект, уже живущий в памяти.
Формально типом ref является int& — ссылка на int.

!!! Ссылка должна быть проинициализирована сразу в момент объявления !!!
Переназначить её нельзя



### 2. pointers
Это специальные типы данных, которые могут хранить адрес какой-либо другой переменной в памяти.
```c++
    int x = 42;
    int* ptr = &x;  // сохраняем адрес в памяти переменной x в указатель ptr
 
    ++x;  // увеличим x на единицу
    std::cout << *ptr << "\n";  // 43
```
Оператор разыменования (унарная звёздочка) противоположен оператору взятия адреса (унарному амперсанду). 
Сравните: ```&x``` — это адрес ```x``` в памяти, а ```*ptr``` — это значение, живущее по адресу, записанному в ```ptr```.

Указатели, в отличие от ссылок, можно переназначать.
Кроме того, есть выделенное значение никуда не ссылающегося указателя — ```nullptr```

Часто указатели используются вместе с динамическим выделением памяти (```malloc / new```).

Отдельно рассмотрим указатели на структуру. Для обращения к полям структуры через указатель есть отдельный оператор ```->```:

```c++
#include <iostream>
 
struct Point {
    double x, y, z;
};
 
int main() {
    Point p = {3.0, 4.0, 5.0};
 
    Point* ptr = &p;
 
    std::cout << (*ptr).x << "\n";  // обращение через * и . требует скобок
    std::cout << ptr->x << "\n";  // то же самое, но чуть короче
}
```

## RAII
Идиома RAII (resource aquitization is initialization) переводится как «захват ресурса должен быть инициализацией объекта». 
Пусть программе требуется какой-то ресурс (память, файл), который надо обязательно «вернуть», когда он будет уже не нужен. Идея состоит в том,
что лучше всего запрашивать этот ресурс в конструкторе некоторого объекта, а освобождать — в деструкторе.
На этой идее построены стандартные контейнеры и так называемые «умные указатели» — классы `unique_ptr` и `shared_ptr` из стандартной библиотеки.

```c++
#include <cstdio>
#include <exception>
#include <string>
 
class CannotOpenFileException {
};
 
class File {
public:
    File(const File&) = delete;
    File& operator = (const File&) = delete;
 
    // Конструктор перемещения
    File(File&& other) noexcept {  // File&& — ссылка на временный объект
        f = other.f;
        other.f = nullptr;  // забираем владение дескриптором у временного объекта other!
    }
 
    // Оператор присваивания с семантикой перемещения
    File& operator = (File&& other) noexcept {
        std::swap(f, other.f);  // обмениваемся дескрипторами с other
        return *this;
    }
 
    // Добавим проверку в деструктор:
    ~File() noexcept {
        if (f != nullptr) {
            fclose(f);
        }
    }
 
    std::string Read() const {
        char buf[100];
        std::fscanf(f, "%99s", buf);
        return buf;
    }
};
```
Теперь можно работать так:
```c++
int main() {
    try {
        File file("input.txt");
        auto str = file.Read();
        // ...
    } catch (const CannotOpenFileException&) {
        std::cout << "File open failure!\n";
    }
}
```






